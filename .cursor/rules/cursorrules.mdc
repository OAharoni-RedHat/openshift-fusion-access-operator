---
alwaysApply: true
---
TECH STACK:
- Language: Go 1.21+
- Framework: Kubebuilder/Controller-Runtime
- Kubernetes: Custom Resources (CRDs), Controllers, RBAC
- Container: Docker with multi-stage builds
- Monitoring: Prometheus metrics
- Testing: Ginkgo/Gomega for e2e, standard Go testing for unit tests
- Build: Makefile with targets for development, testing, and deployment

ARCHITECTURE:
- Kubernetes Operator pattern with custom controllers
- Event-driven architecture with Kubernetes events
- Structured logging with leveled output

GO CODING STANDARDS:
- Follow Go best practices and idioms
- Use gofmt, golint, and go vet for code quality
- Prefer composition over inheritance
- Use meaningful variable and function names
- Keep functions small and focused (max 50 lines when possible)
- Use Go modules for dependency management
- Error handling: always check and handle errors appropriately
- Use context.Context for cancellation and timeouts
- Prefer interfaces for testability

KUBERNETES OPERATOR PATTERNS:
- Implement proper controller reconciliation logic
- Use controller-runtime's predicate filtering
- Handle resource ownership with OwnerReferences
- Implement proper status updates with conditions
- Use finalizers for cleanup operations
- Follow Kubernetes API conventions for resource naming
- Implement proper RBAC with least privilege principle
- Use structured logging with controller-runtime's logger

TESTING REQUIREMENTS:
- Write unit tests for all business logic
- Use table-driven tests where appropriate
- Mock external dependencies (Kubernetes API, etc.)
- Write integration tests for controllers
- Use Ginkgo/Gomega for e2e tests
- Aim for 80%+ code coverage
- Test error conditions and edge cases
- Use test fixtures for complex scenarios
- Never use the --ginkgo.dry-run option
- Always run e2e tests from the makefile
- Commit all changes each time an additional test starts passing

ERROR HANDLING:
- Always return errors, don't panic
- Wrap errors with context using fmt.Errorf with %w verb
- Use controller-runtime's Result pattern for reconciliation
- Log errors at appropriate levels
- Implement exponential backoff for retries
- Use custom error types when beneficial

LOGGING:
- Use structured logging with controller-runtime's logger
- Include relevant context (namespace, name, etc.)
- Use appropriate log levels (Debug, Info, Error)
- Don't log sensitive information
- Log important state transitions
- Use consistent field names across log entries

SECURITY:
- Implement proper RBAC permissions
- Validate all user inputs
- Use SecurityContext in pod specifications
- Follow principle of least privilege
- Handle sensitive data appropriately
- Implement proper authentication and authorization

PERFORMANCE:
- Use resource limits and requests in deployments
- Implement efficient reconciliation loops
- Use informers and caches properly
- Avoid unnecessary API calls
- Use appropriate timeouts for operations
- Monitor resource usage with metrics

DOCUMENTATION:
- Include comprehensive README files
- Document all public APIs with Go doc comments
- Include examples in config/samples/
- Update CRD descriptions and validation
- Maintain design documents for complex features and include any alternatives
- Document operational procedures

DEPENDENCIES:
- Use controller-runtime for Kubernetes operations
- Use logr for structured logging
- Use Prometheus client for metrics
- Prefer standard library when possible
- Keep dependencies minimal and well-maintained
- Update dependencies regularly for security patches
- Always use UBI base images

When suggesting code changes:
1. Ensure Kubernetes best practices are followed
2. Consider the impact on cluster stability
3. Implement proper error handling and recovery
4. Include appropriate tests
5. Follow Go conventions and idioms
6. Consider the operational aspects of the change
7. Ensure backwards compatibility when possible
8. Document any breaking changes 
9. Commit all changes with a concise summary
10. Prefer modifying existing make targets instead of creating new ones
